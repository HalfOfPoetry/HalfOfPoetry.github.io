<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DLL注入之注册表注入</title>
    <url>/2020/05/07/DLL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h3 id="注册表注入DLL"><a href="#注册表注入DLL" class="headerlink" title="注册表注入DLL"></a>注册表注入DLL</h3><p>顾名思义，就是通过注册表的方式，把需要的执行的代码片段，注入到目标程序中，使目标程序执行指定的代码片段，从而达到预期效果。<br>该方式依赖user32.dll，也就是说，需要可执行程序调用到这个系统动态库，我们注入的dll才会被执行到。<br>你应该也发现了，这个意思就是这是一种全局的注入，也就是说，所有调用到user32.dll的程序，都会调用到我们注入成功的dll，所以用这种方式还是要精心设计一下程序思路和限制条件。</p>
<h3 id="注册表位置："><a href="#注册表位置：" class="headerlink" title="注册表位置："></a>注册表位置：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; AppInit_Dlls(64位程序读取)</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows [AppInit_DLLs]</span><br><span class="line"></span><br><span class="line">AppInit_Dlls(32位程序读取)</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows [AppInit_DLLs]</span><br><span class="line"></span><br><span class="line">32位系统：</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows [AppInit_DLLs]</span><br></pre></td></tr></table></figure>
<h3 id="注册表的认识："><a href="#注册表的认识：" class="headerlink" title="注册表的认识："></a>注册表的认识：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册表根：</span><br><span class="line">&#x2F;&#x2F; HKEY_CLASSES_ROOT</span><br><span class="line">&#x2F;&#x2F; HKEY_LOCAL_MACHINE</span><br><span class="line">&#x2F;&#x2F; HKEY_CURRENT_USER</span><br><span class="line">&#x2F;&#x2F; HKEY_USERS</span><br><span class="line">&#x2F;&#x2F; HKEY_CURRENT_CONFIG</span><br></pre></td></tr></table></figure>
<p>这几个的意义不多做阐述，需要自行了解每个节点的意义，但是其实从命名上也能猜出一二<br>需要了解的是这几个玩意儿：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; AppInit_DLLs  LoadAppInit_DLLs RequireSignedAppInit_DLLs</span><br></pre></td></tr></table></figure>
<p>AppInit_DLLs:是注册表在中的一个系统设置项，它的值可以为一个dll路径列表,其实这里就是我们要注入的dll（注意：这里是全局注入）<br>LoadAppInit_DLLs：真正做过该内容开发的人，就会发现，xp下是没有这个项的，而大于win7的系统版本下才有这个项，LoadAppInit_DLLs 为1开启，为0关闭，（Win7默认为0）<br>RequireSignedAppInit_DLLs：这个的xp下也是没有的，值为1表明模块需要签名才能加载，反之则不行</p>
<p>AppInit_DLLs详细的键值介绍，可以查看官方文档（Win7）：<br><a href="https://docs.microsoft.com/zh-cn/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2?redirectedfrom=MSDN" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2?redirectedfrom=MSDN</a></p>
<h3 id="需要认识的API"><a href="#需要认识的API" class="headerlink" title="需要认识的API"></a>需要认识的API</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; API: RegOpenKeyEx RegSetValueEx RegQueryValueEx RegCloseKey</span><br><span class="line">&#x2F;&#x2F; 权限：KEY_READ KEY_WRITE KEY_EXECUTE KEY_ALL_ACCESS</span><br><span class="line">&#x2F;&#x2F; 涉及的数据类型：REG_SZ REG_DWORD</span><br></pre></td></tr></table></figure>
<p>RegOpenKeyEx：打开注册表路径，调用时候，只需要打开到所需要修改设置项的路径，例如：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows （真正调用的时候注意转义）<br>再打开注册表的时候，可以通过设置：KEY_READ KEY_WRITE KEY_EXECUTE KEY_ALL_ACCESS来获取读写权限，当然也有可能获取失败的时候，所以要关注返回值</p>
<p>RegQueryValueEx：查询对应的键值<br>RegSetValueEx：设置键值<br>RegCloseKey：关闭当前打开的注册表<br>在调用过程中注意返回值类型，可以用ERROR_SUCCESS去判断是否调用成功，其他类型可以查看相关文档。<br>其他不做赘述了</p>
<h3 id="写一个简单demo："><a href="#写一个简单demo：" class="headerlink" title="写一个简单demo："></a>写一个简单demo：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HKEY hKey;</span><br><span class="line">	<span class="keyword">char</span> *csAppInitValue = <span class="string">"C:\\test.dll"</span>;</span><br><span class="line">	DWORD dwLoadAppInitValue = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> csSubKey[] = <span class="string">"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\"</span>;</span><br><span class="line">    LSTATUS lsRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,csSubKey,<span class="number">0</span>,KEY_ALL_ACCESS,&amp;hKey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lsRet != ERROR_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Open Key Failed....\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> csBuf[<span class="number">100</span>] = <span class="string">""</span>;</span><br><span class="line">	DWORD dwSize = <span class="number">100</span>;</span><br><span class="line">	DWORD dwType = <span class="number">0</span>;</span><br><span class="line">	RegQueryValueEx(hKey,<span class="string">"AppInit_DLLs"</span>,<span class="number">0</span>,&amp;dwType,(LPBYTE)csBuf,&amp;dwSize);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> nSize = <span class="built_in">strlen</span>(csAppInitValue);</span><br><span class="line">	lsRet = RegSetValueEx(hKey,<span class="string">"AppInit_DLLs"</span>,<span class="number">0</span>,REG_SZ,(<span class="keyword">const</span> BYTE *)csAppInitValue,nSize+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lsRet != ERROR_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Set Key Failed....\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	lsRet = RegSetValueEx(hKey,<span class="string">"LoadAppInit_DLLs"</span>,<span class="number">0</span>,REG_DWORD,(<span class="keyword">const</span> BYTE *)&amp;dwLoadAppInitValue,<span class="keyword">sizeof</span>(DWORD));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lsRet != ERROR_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Set Key Failed....\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RegCloseKey(hKey);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>对了，如何查看程序调用了哪些dll，这是一个新手问题，在这里我推荐一个很好用的工具：Process Explorer<br>这个工具，可以定位程序包括pid与调用的动态库等几乎所有的程序相关信息，具体怎么用，可以自行网络搜索，或者后续等我出一篇使用经验，哈哈哈，这个可能要等很久。<br>有兴趣可以联系我，一起分享学习经验，哈哈哈~</p>
]]></content>
      <tags>
        <tag>Dll_Inject</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome</title>
    <url>/2020/04/30/Welcome/</url>
    <content><![CDATA[<h2 id="这是开始"><a href="#这是开始" class="headerlink" title="这是开始"></a>这是开始</h2><p>欢迎来到这里<br>我会在这里<br>分享日常<br>分享代码<br>分享生活  </p>
<p>ありがとうございます</p>
]]></content>
      <tags>
        <tag>welcome</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows编程之DLL注入</title>
    <url>/2020/05/07/Windows%E7%BC%96%E7%A8%8B%E4%B9%8BDLL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h3 id="Windows编程中不得不懂的一项实用技巧"><a href="#Windows编程中不得不懂的一项实用技巧" class="headerlink" title="Windows编程中不得不懂的一项实用技巧"></a>Windows编程中不得不懂的一项实用技巧</h3><p>就是DLL动态库注入技术</p>
<p>关于这一系列的注入知识，后续会针对每一项技巧进行专门的博文编写<br>这篇博文，简单讲述现在常用的四种技巧</p>
<h3 id="一、注册表注入"><a href="#一、注册表注入" class="headerlink" title="一、注册表注入"></a>一、注册表注入</h3><p>顾名思义，就是通过注册表的方式，把需要的执行的代码片段，注入到目标程序中，使目标程序执行指定的代码片段，从而达到预期效果。</p>
<h3 id="二、函数转发注入"><a href="#二、函数转发注入" class="headerlink" title="二、函数转发注入"></a>二、函数转发注入</h3><p>这个方式，是通过替换目标程序的动态库，可以定义dll入口等函数，而后转发原函数调用内容至原动态库函数接口，这样的动作之后，就可以调用注入的代码片段，从而达到预期效果。</p>
<h3 id="三、挂钩注入"><a href="#三、挂钩注入" class="headerlink" title="三、挂钩注入"></a>三、挂钩注入</h3><p>这项技术，要是有了解过钩子技术的人就会比较容易懂，主要通过挂钩相关程序下，或者全局下的相关消息，或者理解成捕获目标消息后，执行指定代码片段，从而达到预期效果。</p>
<h3 id="四、远程注入"><a href="#四、远程注入" class="headerlink" title="四、远程注入"></a>四、远程注入</h3><p>这里的远程，不要想得太复杂，不是我们平时所谓的网络中的远程，这里的意思是，通过控制内存，在内存段上为目标程序开辟一条线程，之后控制该线程执行相关的DLL。</p>
<h3 id="以上四种方式就是常用的几种DLL注入技巧"><a href="#以上四种方式就是常用的几种DLL注入技巧" class="headerlink" title="以上四种方式就是常用的几种DLL注入技巧"></a>以上四种方式就是常用的几种DLL注入技巧</h3><p>都各自有利有弊<br>注册表注入的方式，最简单，但是这种方式依赖于user32.dll这个系统自带dll，当可执行程序需要调用到这个动态库，才可形成注入，而且我试过win8，win10下好像支持效果不是太好；<br>函数转发的方式，最直观，但是现在大多数企业级的目标程序，是对DLL进行注册校验的，一旦出现非法dll则无法实现效果，所以需要采取该方式的dll开发商，需要经过认证；<br>挂钩的方式，弊端就在于依赖于windows的消息，无消息则无法注入；<br>远程注入的方式是个人相对推荐的，其实认真想想某些病毒就是通过这样的手段，使病毒程序执行于无形之中。</p>
<p>后续有空的话，我会详细编写各个方式的实现博文，写在这里，激励自己写下去的动力。</p>
]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>基于MNist数据集进行DeepLearning学习</title>
    <url>/2020/05/07/%E5%9F%BA%E4%BA%8EMNist%E6%95%B0%E6%8D%AE%E9%9B%86%E8%BF%9B%E8%A1%8CDeepLearning%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h3 id="什么是MNist"><a href="#什么是MNist" class="headerlink" title="什么是MNist"></a>什么是MNist</h3><p>MNist手写数据集，大多数示例使用手写数字的MNIST数据集[1]。该数据集包含60000个用于训练的示例和10,000个用于测试的示例。这些数字已经过尺寸标准化并位于图像中心，图像是固定大小(28x28像素)，其值为0到1。<br>为简单起见，每个图像都被平展并转换为784(28 * 28)个特征的一维numpy数组。<br>大概是这样：<br><img src="http://q9lfq1grf.bkt.clouddn.com/mnist.jpeg" alt="pic"><br>我们可以通过pip或者离线安装方式加载该数据集<br>在这里，我是直接用TensorFlow2了，很多操作都相对方便，本文的代码也是基于TensorFlow2的</p>
<p>为什么会用到这个数据集？<br>以我看来，学会训练这个数据集，不仅可以用来识别日常中的手写数字，这个简直就是深度学习中的Hello world，学了这个，可以说进入了深度学习的ABC了</p>
<h3 id="调用流程"><a href="#调用流程" class="headerlink" title="调用流程"></a>调用流程</h3><p>文字描述比较麻烦，我做了一张流程图直接看：<br><img src="http://q9lfq1grf.bkt.clouddn.com/mnist_visio.jpg" alt="pic2"></p>
<h3 id="流程解析"><a href="#流程解析" class="headerlink" title="流程解析"></a>流程解析</h3><p>在开发流程中，我们需要将数据集，分解成训练集和测试集，（有时候还有验证集）<br>顾名思义，训练集就是投入到训练过程中，将训练出一套模型后，用测试集的数据进行校验，来测算准确率。<br>由于数据集中是简单的数据集，文字识别类的，每个像素可以视为非黑即白，所以，我们可以对每个像素点，进行</p>
<h4 id="归一化操作"><a href="#归一化操作" class="headerlink" title="归一化操作"></a>归一化操作</h4><p>什么是归一化操作？就是把目标值全部转化为1，非目标值转化成0，这样我们就可以把数据集中的每组numpy数据的每个像素点，都识别为0或者1，来降低训练难度,可以理解成以下样子：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 归一化操作</span></span><br><span class="line">x_train,x_test = x_train / <span class="number">255.0</span>,x_test / <span class="number">255.0</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">000010001...</span><br><span class="line">000100010...</span><br><span class="line">000101001...</span><br><span class="line">000100010...</span><br><span class="line">000100010...</span><br><span class="line">............</span><br></pre></td></tr></table></figure>
<p>同样的，为方便标签的识别，我们可以进行</p>
<h4 id="把标签转独热编码"><a href="#把标签转独热编码" class="headerlink" title="把标签转独热编码"></a>把标签转独热编码</h4><p>何为独热编码？<br>独热编码即 One-Hot 编码,又称一位有效编码,其方法是使用N位状态寄存器来对N个状态进行编码,每个状态都由他独立的寄存器位,并且在任意时候,其中只有一位有效。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 把标签转成独热编码</span></span><br><span class="line">y_train = tf.keras.utils.to_categorical(y_train,num_classes=<span class="number">10</span>)</span><br><span class="line">y_test = tf.keras.utils.to_categorical(y_test,num_classes=<span class="number">10</span>)</span><br></pre></td></tr></table></figure>
<p>我们在这里拿MNist数据集举例，0-9有十位数字，所以独热编码位有10位，我们就可以把1独热为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0100000000]</span><br></pre></td></tr></table></figure>
<p>把3独热为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[0001000000]</span><br></pre></td></tr></table></figure>
<p>这样看，就清晰了很多</p>
<h4 id="构建Dataset对象和模型的过程中"><a href="#构建Dataset对象和模型的过程中" class="headerlink" title="构建Dataset对象和模型的过程中"></a>构建Dataset对象和模型的过程中</h4><p>我们需要用repeat和batch分别对训练集和测试集配置训练周期和批次大小（一次训练多少个数据）<br>这里我们要有一个认知，我们在拥有测试集的时候，我们后续要用测试集进行验证，我们就得对测试集做与训练集配置相同的操作，这样可以计算统计出最终的准确率，当然如果你连测试集都没有，那就无需多言<br>构建模型的时候，我们这里采用keras自带的模型</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 构建模型</span></span><br><span class="line">model = keras.models.Sequential([</span><br><span class="line">    keras.layers.Flatten(input_shape=(<span class="number">28</span>,<span class="number">28</span>)), <span class="comment"># 数据扁平化 784 个数值</span></span><br><span class="line">    keras.layers.Dense(<span class="number">10</span>,activation=<span class="string">'softmax'</span>) <span class="comment"># 激活函数为softmax输出为10个神经元的全连接</span></span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>因为我们输入的每张图片的numpy值为28*28像素，所以前面的归一化操作出来的数据也是28*28，所以输入的神经元个数即：input_shape=(28,28)，通过Flatten进行数据扁平化成784个数值<br>之后我们定义其为输出位10个神经元的全连接层</p>
<h4 id="关于优化器"><a href="#关于优化器" class="headerlink" title="关于优化器"></a>关于优化器</h4><p>什么是优化器？<br>在机器学习中，有很多优化方法来试图寻找模型的最优解。比如神经网络中可以采取最基本的梯度下降法。<br>梯度下降法是最基本的一类优化器，目前主要分为三种梯度下降法：标准梯度下降法(GD, Gradient Descent)，随机梯度下降法(SGD, Stochastic Gradient Descent)及批量梯度下降法(BGD, Batch Gradient Descent)。<br>在这里我们采用随机梯度下降法，关于这一个知识点，后续可能会出一个专门解读，或者大家可以去百度一下，先进行自我学习。<br>以下是几种梯度下降法寻找最低值的立体三维解析：<br><img src="http://q9lfq1grf.bkt.clouddn.com/v2-05bafbc0557270f96773e544b2ae683e_hd.webp" alt="pic3"><br>后续博文会慢慢解释，大家先看着了解一二，或者百度学习更深的算法，咱们一起探讨学习。</p>
<h4 id="训练模型"><a href="#训练模型" class="headerlink" title="训练模型"></a>训练模型</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(data,label)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        <span class="comment"># 传入数据预测结果</span></span><br><span class="line">        predictions = model(data)</span><br><span class="line">        <span class="comment"># 计算loss</span></span><br><span class="line">        loss = tf.keras.losses.MSE(label,predictions) <span class="comment"># 二次代价函数</span></span><br><span class="line">        <span class="comment"># 计算权值调整</span></span><br><span class="line">        gradients = tape.gradient(loss,model.trainable_variables)</span><br><span class="line">        <span class="comment"># 进行权值调整</span></span><br><span class="line">        optimizer.apply_gradients(zip(gradients,model.trainable_variables))</span><br><span class="line">        <span class="comment"># 计算平均loss</span></span><br><span class="line">        train_loss(loss)</span><br><span class="line">        <span class="comment"># 计算平均准确率</span></span><br><span class="line">        train_accuracy(label,predictions)</span><br></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型测试</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_step</span><span class="params">(data,label)</span>:</span></span><br><span class="line">    <span class="comment"># 传入数据预测结果</span></span><br><span class="line">    predictions = model(data)</span><br><span class="line">    <span class="comment"># 计算loss </span></span><br><span class="line">    t_loss = tf.keras.losses.MSE(label,predictions)</span><br><span class="line">    <span class="comment"># 计算平均loss</span></span><br><span class="line">    test_loss(t_loss)</span><br><span class="line">    <span class="comment"># 计算平均准确率</span></span><br><span class="line">    test_accuracy(label,predictions)</span><br></pre></td></tr></table></figure>
<p>以上是两个函数的定义，重点要注意的是我们这里采用均方差损失函数（即二次代价函数）来计算误差，从而进一步调整权值，计算训练过程中的模型准确率<br>除了二次代价函数外，还有交叉熵损失函数，大家有兴趣后续可以使用交叉熵的方式，来计算误差，而后对比结果关系。<br>我个人用的环境是vscode+anaconda（配置python3.6—64）<br>我的运行结果如下：<br><img src="http://q9lfq1grf.bkt.clouddn.com/MNist_res.png" alt="pic4"><br>可以看到<br>1.由于我使用的CPU版本的TensorFlow来训练，所以训练速度相对比较久，所以有条件有显卡的童鞋，建议使用GPU版本，速度不是提升一点点<br>2.在训练过程中，训练集的准确率和测试集的准确率都有提高的趋势，这都归功于我们前面配置的优化器，以及每个训练过程中权值调整,我推荐大家去修改这些值，或者屏蔽这些值，来进一步了解这些带来的变化。</p>
<h3 id="模型的保存"><a href="#模型的保存" class="headerlink" title="模型的保存"></a>模型的保存</h3><p>模型的保存有很多种方式，我们这里采用Checkpoint的方式，保存最优三个模型：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 定义模型保存</span></span><br><span class="line">ckpt = tf.train.Checkpoint(step=tf.Variable(<span class="number">1</span>), <span class="comment"># 训练的次数从1开始</span></span><br><span class="line">    optimizer=optimizer,model=model)</span><br><span class="line">manager = tf.train.CheckpointManager(ckpt,<span class="string">'tf2_ckpts'</span>,max_to_keep=<span class="number">3</span>) <span class="comment"># 文件夹中最多保存3个模型</span></span><br></pre></td></tr></table></figure>
<p>之后在每个训练周期进行save()模型保存即可<br>模型的载入：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 模型载入</span></span><br><span class="line">ckpt = tf.train.Checkpoint(step=tf.Variable(<span class="number">1</span>),optimizer=optimizer,model=model)</span><br><span class="line">ckpt.retore(tf.train.latest_checkpoint(<span class="string">'tf2_ckpts/'</span>)) <span class="comment"># 在文件夹中取出最新的模型</span></span><br></pre></td></tr></table></figure>
<p><img src="http://q9lfq1grf.bkt.clouddn.com/MNist_model_res.png" alt="pic5"></p>
<h3 id="写一个demo"><a href="#写一个demo" class="headerlink" title="写一个demo"></a>写一个demo</h3><p>写一个demo来试试结果</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf </span><br><span class="line"><span class="keyword">from</span> tensorflow.keras.optimizers <span class="keyword">import</span> SGD</span><br><span class="line"><span class="keyword">from</span> tensorflow <span class="keyword">import</span> keras</span><br><span class="line"></span><br><span class="line"><span class="comment"># 载入数据集</span></span><br><span class="line">mnist = keras.datasets.mnist</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练集和测试集</span></span><br><span class="line">(x_train,y_train),(x_test,y_test) = mnist.load_data()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 归一化操作</span></span><br><span class="line">x_train,x_test = x_train / <span class="number">255.0</span>,x_test / <span class="number">255.0</span></span><br><span class="line">print(x_train.shape,x_test.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把标签转成独热编码</span></span><br><span class="line">y_train = tf.keras.utils.to_categorical(y_train,num_classes=<span class="number">10</span>)</span><br><span class="line">y_test = tf.keras.utils.to_categorical(y_test,num_classes=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建dataset对象</span></span><br><span class="line">mnist_train = tf.data.Dataset.from_tensor_slices((x_train,y_train))</span><br><span class="line"><span class="comment"># 训练周期</span></span><br><span class="line">mnist_train = mnist_train.repeat(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 批次大小 一次32个数据</span></span><br><span class="line">mnist_train = mnist_train.batch(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建detaset对象</span></span><br><span class="line">mnist_test = tf.data.Dataset.from_tensor_slices((x_test,y_test))</span><br><span class="line"><span class="comment"># 训练周期</span></span><br><span class="line">mnist_test = mnist_test.repeat(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># 批次大小</span></span><br><span class="line">mnist_test = mnist_test.batch(<span class="number">32</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建模型</span></span><br><span class="line">model = keras.models.Sequential([</span><br><span class="line">    keras.layers.Flatten(input_shape=(<span class="number">28</span>,<span class="number">28</span>)), <span class="comment"># 数据扁平化 784 个数值</span></span><br><span class="line">    keras.layers.Dense(<span class="number">10</span>,activation=<span class="string">'softmax'</span>) <span class="comment"># 激活函数为softmax输出为10个神经元的全连接</span></span><br><span class="line">])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 优化器定义</span></span><br><span class="line">optimizer = tf.keras.optimizers.SGD(<span class="number">0.1</span>)</span><br><span class="line"><span class="comment"># 训练loss</span></span><br><span class="line">train_loss = tf.keras.metrics.Mean(name=<span class="string">'train_loss'</span>)</span><br><span class="line"><span class="comment"># 训练准确率计算</span></span><br><span class="line">train_accuracy = tf.keras.metrics.CategoricalAccuracy(name=<span class="string">'train_accuracy'</span>)</span><br><span class="line"><span class="comment"># 测试loss</span></span><br><span class="line">test_loss = tf.keras.metrics.Mean(name=<span class="string">"test_loss"</span>)</span><br><span class="line"><span class="comment"># 测试准确率计算</span></span><br><span class="line">test_accuracy = tf.keras.metrics.CategoricalAccuracy(name=<span class="string">"test_accuracy"</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">train_step</span><span class="params">(data,label)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> tf.GradientTape() <span class="keyword">as</span> tape:</span><br><span class="line">        <span class="comment"># 传入数据预测结果</span></span><br><span class="line">        predictions = model(data)</span><br><span class="line">        <span class="comment"># 计算loss</span></span><br><span class="line">        loss = tf.keras.losses.MSE(label,predictions) <span class="comment"># 二次代价函数</span></span><br><span class="line">        <span class="comment"># 计算权值调整</span></span><br><span class="line">        gradients = tape.gradient(loss,model.trainable_variables)</span><br><span class="line">        <span class="comment"># 进行权值调整</span></span><br><span class="line">        optimizer.apply_gradients(zip(gradients,model.trainable_variables))</span><br><span class="line">        <span class="comment"># 计算平均loss</span></span><br><span class="line">        train_loss(loss)</span><br><span class="line">        <span class="comment"># 计算平均准确率</span></span><br><span class="line">        train_accuracy(label,predictions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型测试</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_step</span><span class="params">(data,label)</span>:</span></span><br><span class="line">    <span class="comment"># 传入数据预测结果</span></span><br><span class="line">    predictions = model(data)</span><br><span class="line">    <span class="comment"># 计算loss </span></span><br><span class="line">    t_loss = tf.keras.losses.MSE(label,predictions)</span><br><span class="line">    <span class="comment"># 计算平均loss</span></span><br><span class="line">    test_loss(t_loss)</span><br><span class="line">    <span class="comment"># 计算平均准确率</span></span><br><span class="line">    test_accuracy(label,predictions)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义模型保存</span></span><br><span class="line">ckpt = tf.train.Checkpoint(step=tf.Variable(<span class="number">1</span>), <span class="comment"># 训练的次数从1开始</span></span><br><span class="line">    optimizer=optimizer,model=model)</span><br><span class="line">manager = tf.train.CheckpointManager(ckpt,<span class="string">'tf2_ckpts'</span>,max_to_keep=<span class="number">3</span>) <span class="comment"># 文件夹中最多保存3个模型</span></span><br><span class="line"></span><br><span class="line">EPOCHS = <span class="number">5</span></span><br><span class="line"><span class="comment"># 训练5个周期</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(EPOCHS):</span><br><span class="line">    <span class="comment"># 循环60000/32 = 1875次 一共有60000个数据，一次取32个数据</span></span><br><span class="line">    <span class="keyword">for</span> image,label <span class="keyword">in</span> mnist_train:</span><br><span class="line">        <span class="comment"># 训练模型</span></span><br><span class="line">        train_step(image,label)</span><br><span class="line">    <span class="comment"># 循环10000/32 = 312.5 ———&gt; 313次</span></span><br><span class="line">    <span class="keyword">for</span> test_image,test_label <span class="keyword">in</span> mnist_test:</span><br><span class="line">        <span class="comment"># 测试模式</span></span><br><span class="line">        test_step(test_image,test_label)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印结果</span></span><br><span class="line">    template = <span class="string">'Epoch &#123;&#125; ,loss: &#123;:.3&#125;, Accuracy &#123;:.3&#125;, Test Loss: &#123;:.3&#125;,Test Accuracy: &#123;:.3&#125;'</span></span><br><span class="line">    print(template.format(epoch + <span class="number">1</span>,</span><br><span class="line">                        train_loss.result(),</span><br><span class="line">                        train_accuracy.result(),</span><br><span class="line">                        test_loss.result(),</span><br><span class="line">                        test_accuracy.result()))</span><br><span class="line">    <span class="comment"># 保存模型</span></span><br><span class="line">    manager.save()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型载入</span></span><br><span class="line">ckpt = tf.train.Checkpoint(step=tf.Variable(<span class="number">1</span>),optimizer=optimizer,model=model)</span><br><span class="line">ckpt.retore(tf.train.latest_checkpoint(<span class="string">'tf2_ckpts/'</span>)) <span class="comment"># 在文件夹中取出最新的模型</span></span><br></pre></td></tr></table></figure>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我也在学习阶段，这一篇是我近期学习所得，也只能说自己接触了这一块的深度学习的hello world了吧，后续继续学习更多的东西，和大家多做学习交流探讨。</p>
]]></content>
      <tags>
        <tag>Deep-Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>【AI记录】机器学习与深度学习</title>
    <url>/2020/04/30/Deep-Learning/</url>
    <content><![CDATA[<h3 id="今天来讲讲机器学习-Machine-Learning，ML-与深度学习（Deep-Learning，DL）"><a href="#今天来讲讲机器学习-Machine-Learning，ML-与深度学习（Deep-Learning，DL）" class="headerlink" title="今天来讲讲机器学习(Machine Learning，ML)与深度学习（Deep Learning，DL）"></a>今天来讲讲机器学习(Machine Learning，ML)与深度学习（Deep Learning，DL）</h3><p>首先，要论这两个东西，得先了解人工智能（AI），AI与机器学习以及深度学习之间的关系，用集合关系来描述，就是：</p>
<p>深度学习包含于机器学习，机器学习包含于AI；</p>
<p>机器学习 作为AI的子领域，也是其核心，可以这么理解：</p>
<p>设计和分析一些算法，可以让计算机进行自动学习。</p>
<p>深度学习 设计灵感，是来源于人类大脑的工作方式，利用深度神经网络来解决特征表达的一种学习过程。为了提高深层神经网络的训练效果，人们对神经元的连接方法以及激活函数等方面做出了调整。其目的在于建立、模拟人脑进行分析学习的神经网络，模仿人脑的机制来解释数据，如文本、图像、声音。</p>
<h3 id="1-应用区别"><a href="#1-应用区别" class="headerlink" title="1.应用区别"></a>1.应用区别</h3><p>机器学习：指纹识别，特征物体检测等</p>
<p>深度学习：文字识别，人链技术，语义分析，智能监控，智能硬件，智能教育，智能医疗等</p>
<h3 id="2-需求的数据量"><a href="#2-需求的数据量" class="headerlink" title="2.需求的数据量"></a>2.需求的数据量</h3><p>机器学习：数据量较小</p>
<p>深度学习：在机器学习的基础上，若有比较庞大的数据量，深度学习的效果更加显著</p>
<h3 id="3-执行时间"><a href="#3-执行时间" class="headerlink" title="3.执行时间"></a>3.执行时间</h3><p>机器学习：相对较少</p>
<p>深度学习：由于训练受到数据量的影响，需要大量的时间进行</p>
<h3 id="4-问题解决方式"><a href="#4-问题解决方式" class="headerlink" title="4.问题解决方式"></a>4.问题解决方式</h3><p>机器学习：遵循标准化程序，将问题拆分，分别解决，之后整合得出答案</p>
<p>深度学习：不拆分，集中解决</p>
<h3 id="选择推荐："><a href="#选择推荐：" class="headerlink" title="选择推荐："></a>选择推荐：</h3><p>传统的机器学习算法比较复杂，不太容易理解，深度学习引入了人工神经网络，比机器学习的表现要好得多，在数据量足够庞大的情况下，个人建议使用选择深度学习。</p>
]]></content>
      <tags>
        <tag>Deep-Learing</tag>
      </tags>
  </entry>
  <entry>
    <title>python猜数字小游戏</title>
    <url>/2020/04/30/python%E7%8C%9C%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="这是一个学习项目"><a href="#这是一个学习项目" class="headerlink" title="这是一个学习项目"></a>这是一个学习项目</h3><p>游戏原理介绍：</p>
<p>这个猜数字的小游戏，相信很多人以前玩过，就是一个人从1-100中随机写一个数字，然后另外一群人去猜，猜一个数字的时候，就会告诉你所猜的数字大了还是小了，渐渐缩小范围，直到最后猜对的人，为最后的胜利者。</p>
<p>现在把生成数字和裁判的角色，交给代码，这样即使只有自己一个人的时候，也可以玩这样的游戏</p>
<p>经过上述游戏分析，我们就可以开始一套简单的思路</p>
<p>1.随机数的生成，我们就得需要用到random模块</p>
<p>2.猜数字的次数为多次，所以我们需要封装一个猜数字的函数</p>
<p>3.需要记录猜数字的区间范围</p>
<p>4.得防止用户使用不得当，输入字符不符导致程序异常</p>
<p>5.游戏过程中玩家终止游戏操作</p>
<h3 id="于是，我们可以根据思路简单编写一下代码："><a href="#于是，我们可以根据思路简单编写一下代码：" class="headerlink" title="于是，我们可以根据思路简单编写一下代码："></a>于是，我们可以根据思路简单编写一下代码：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">n = random.randint(<span class="number">1</span>,<span class="number">100</span>) <span class="comment"># 生成1 - 100的随机整</span></span><br><span class="line"></span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">low = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">high = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_number</span><span class="params">(low = <span class="number">1</span>,high = <span class="number">100</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"Please enter an integer"</span>,low,<span class="string">"to"</span>,high,<span class="string">":"</span>)</span><br><span class="line"></span><br><span class="line">        guess = input()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> guess.isdigit():<span class="comment"># 字符串是否为数字，是True，否False</span></span><br><span class="line"></span><br><span class="line">            guess = int(guess)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> guess</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(<span class="string">"Game Init"</span>)</span><br><span class="line"></span><br><span class="line">guess = get_number()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"step :"</span>,step)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> guess == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"quit"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> guess &lt; n:</span><br><span class="line"></span><br><span class="line">        print(guess,<span class="string">"is low"</span>)</span><br><span class="line"></span><br><span class="line">        low = guess + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> guess &gt; n:</span><br><span class="line"></span><br><span class="line">        print(guess,<span class="string">"is high"</span>)</span><br><span class="line"></span><br><span class="line">        high = guess - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"you win!"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    guess = get_number(low,high) <span class="comment"># 继续猜</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(<span class="string">"Game Over"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="执行结果如下："><a href="#执行结果如下：" class="headerlink" title="执行结果如下："></a>执行结果如下：</h3><p><img src="https://img-blog.csdnimg.cn/20200323150728216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNjc2ODc=,size_16,color_FFFFFF,t_70" alt="图片"></p>
<p>简单易学，轻松上手</p>
<p>可以根据自己对游戏的理解和需求，封装更多有趣的玩法</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python3写一个简单的百度翻译小字典</title>
    <url>/2020/04/30/python%E7%99%BE%E5%BA%A6%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h3 id="利用python3写一个简单的百度翻译小字典"><a href="#利用python3写一个简单的百度翻译小字典" class="headerlink" title="利用python3写一个简单的百度翻译小字典"></a>利用python3写一个简单的百度翻译小字典</h3><p>声明：此例子为学习例子，通过百度翻译的XHR来实现的</p>
<p>最近在重新学习python3，尝试着利用它来抓取网页上的数据。</p>
<p>在用百度翻译的时候，看到<br><img src="https://img-blog.csdnimg.cn/20200306170733883.png" alt="pic"><br>突发奇想想做一个百度小字典的玩意儿</p>
<p>于是开始了学习之路</p>
<h3 id="首先利用浏览器的网页工具查看其工作原理是利用xhr请求来获取数据"><a href="#首先利用浏览器的网页工具查看其工作原理是利用xhr请求来获取数据" class="headerlink" title="首先利用浏览器的网页工具查看其工作原理是利用xhr请求来获取数据"></a>首先利用浏览器的网页工具查看其工作原理是利用xhr请求来获取数据</h3><p>于是我们可以<br><img src="https://img-blog.csdnimg.cn/20200306171320636.png" alt="pic2"><br>在network工具下选择xhr协议</p>
<p>在preview模式中找到具体的流数据（json）<br><img src="https://img-blog.csdnimg.cn/20200306171540999.png" alt="pic3"><br>在headres中我们最先注意的只有两个<br><img src="https://img-blog.csdnimg.cn/20200306171916906.png" alt="pic4"><br>就是找到Request Url和Method，很明显是<a href="https://fanyi.baidu.com/sug和post" target="_blank" rel="noopener">https://fanyi.baidu.com/sug和post</a></p>
<p>所以我们确定了用到的东西有</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests        <span class="comment">#导入requests包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure>
<p>既然是post，我们就得去寻找post的数据是什么<br><img src="https://img-blog.csdnimg.cn/2020030617224252.png" alt="pic5"><br>可以发现，这是一个很简单的数据模式</p>
<h3 id="我们就可以先定义"><a href="#我们就可以先定义" class="headerlink" title="我们就可以先定义"></a>我们就可以先定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">From_data = &#123;<span class="string">'kw'</span>,<span class="string">'hello'</span>&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://fanyi.baidu.com/sug'</span></span><br></pre></td></tr></table></figure>
<p>请求方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = requests.post(url,data=From_data)</span><br></pre></td></tr></table></figure>

<p>获取表单方式后进行json转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content = json.loads(response.text)</span><br></pre></td></tr></table></figure>
<p>content中有即是我们要的查询结果。</p>
<h3 id="截图运行效果如下（截图附代码）："><a href="#截图运行效果如下（截图附代码）：" class="headerlink" title="截图运行效果如下（截图附代码）："></a>截图运行效果如下（截图附代码）：</h3><p><img src="https://img-blog.csdnimg.cn/202003061727026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNjc2ODc=,size_16,color_FFFFFF,t_70" alt="pic6"><br>后面的格式如何转换，就是进一步的事了，这简单的百度小词典就完成啦~</p>
<p>PS：利用这种方式，可以实现很多借用第三方的功能。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下send错误代码32</title>
    <url>/2020/04/30/Linux%E4%B8%8Bsend%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%8132/</url>
    <content><![CDATA[<h3 id="问题描述：今天写程序，socket后send出现这个问题，send的返回值为-1，而errno为32，这个错误代码为broken-pipe，即管道破裂。"><a href="#问题描述：今天写程序，socket后send出现这个问题，send的返回值为-1，而errno为32，这个错误代码为broken-pipe，即管道破裂。" class="headerlink" title="问题描述：今天写程序，socket后send出现这个问题，send的返回值为-1，而errno为32，这个错误代码为broken pipe，即管道破裂。"></a>问题描述：今天写程序，socket后send出现这个问题，send的返回值为-1，而errno为32，这个错误代码为broken pipe，即管道破裂。</h3><p>问题形成原因：后来通过排查研究，发现出现该种问题出现的可能性为以下两种：</p>
<p>1.socket失败，与服务器端的链接没有成功，从而管道破裂。</p>
<p>2.服务端将客户端的socket断开，一样造成这样的问题。</p>
<h3 id="此时这样的程序收到broken-pipe的信号，会自动退出我们可以在产生信号前利用方法-signal-int-signum-sighandler-t-handler-设置信号的处理。如果没有调用此方法，系统就会调用默认处理方法：中止程序，显示提示信息-就是我们经常遇到的问题-。我们可以调用系统的处理方法，也可以自定义处理方法。"><a href="#此时这样的程序收到broken-pipe的信号，会自动退出我们可以在产生信号前利用方法-signal-int-signum-sighandler-t-handler-设置信号的处理。如果没有调用此方法，系统就会调用默认处理方法：中止程序，显示提示信息-就是我们经常遇到的问题-。我们可以调用系统的处理方法，也可以自定义处理方法。" class="headerlink" title="此时这样的程序收到broken pipe的信号，会自动退出我们可以在产生信号前利用方法 signal(int signum, sighandler_t handler) 设置信号的处理。如果没有调用此方法，系统就会调用默认处理方法：中止程序，显示提示信息(就是我们经常遇到的问题)。我们可以调用系统的处理方法，也可以自定义处理方法。"></a>此时这样的程序收到broken pipe的信号，会自动退出我们可以在产生信号前利用方法 signal(int signum, sighandler_t handler) 设置信号的处理。如果没有调用此方法，系统就会调用默认处理方法：中止程序，显示提示信息(就是我们经常遇到的问题)。我们可以调用系统的处理方法，也可以自定义处理方法。</h3><p>对一个已经收到FIN包的socket调用read方法, 如果接收缓冲已空, 则返回0,<br>这就是常说的表示连接关闭. 但第一次对其调用write方法时, 如果发送缓冲没问题,<br>会返回正确写入(发送). 但发送的报文会导致对端发送RST报文,<br>因为对端的socket已经调用了close, 完全关闭, 既不发送, 也不接收数据. 所以,<br>第二次调用write方法(假设在收到RST之后), 会生成SIGPIPE信号, 导致进程退出.</p>
<h3 id="为了避免进程退出-可以捕获SIGPIPE信号-或者忽略它"><a href="#为了避免进程退出-可以捕获SIGPIPE信号-或者忽略它" class="headerlink" title="为了避免进程退出, 可以捕获SIGPIPE信号, 或者忽略它,"></a>为了避免进程退出, 可以捕获SIGPIPE信号, 或者忽略它,</h3><p>给它设置SIG_IGN信号处理函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">signal(SIGPIPE, SIG_IGN);</span><br></pre></td></tr></table></figure>
<p>这样, 第二次调用write方法时, 会返回-1, 同时errno置为SIGPIPE.<br>程序便能知道对端已经关闭.</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Arm板Linux移植随身WIFI</title>
    <url>/2020/05/07/Arm%E6%9D%BFLinux%E7%A7%BB%E6%A4%8D%E9%9A%8F%E8%BA%ABWIFI/</url>
    <content><![CDATA[<h3 id="Arm板Linux移植随身WIFI并连接上网络，如米WIFI"><a href="#Arm板Linux移植随身WIFI并连接上网络，如米WIFI" class="headerlink" title="Arm板Linux移植随身WIFI并连接上网络，如米WIFI"></a>Arm板Linux移植随身WIFI并连接上网络，如米WIFI</h3><p>本文是本人博客的版本迁移，将叙述本人2015年Arm板linux系统上实现米wifi驱动的移植以及到连接上wifi的全过程，360wifi等类似，本文中会有提到</p>
<p>PS：交叉编译等本文不多做讲解</p>
<p>在执行之前，先确定你linux系统下armlinux系统的源码目录在哪里（Ps：我的源码目录为/usr/linux2.6.32.2）</p>
<h3 id="首先"><a href="#首先" class="headerlink" title="首先"></a>首先</h3><p>得先获取无线网卡驱动的源码，后，解压到linux系统上，（ps：这里我是解压在/usr目录下）</p>
<p>以下为无线网卡驱动的源码下载地址，大家可以去下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;download.csdn.net&#x2F;detail&#x2F;u013267687&#x2F;8671849</span><br></pre></td></tr></table></figure>
<h3 id="解压完后"><a href="#解压完后" class="headerlink" title="解压完后"></a>解压完后</h3><p>在WIFI驱动的源代码根目录下，执行gedit MakeFile，进行修改，修改内容如下：</p>
<p>找到“PLATFORM = PC”语句将其注释掉，即修改为：“#PLATFORM = PC”</p>
<p>找到“#PLATFORM = SMDK”语句将其注释的语句解除，即“PLATFORM = SMDK”</p>
<p>修改完以上内容还需修改一处：</p>
<p>找到“ifeq ($(PLATFORM),SMDK)”语句，将其后两句语句修改为如下内容：</p>
<p>LINUX_SRC = /usr/linux-2.6.32.2 //注意，此处为你的源码目录<br>CROSS_COMPILE = arm-linux-</p>
<p>修改完以上后，即可保存关闭该文件</p>
<h3 id="后进入"><a href="#后进入" class="headerlink" title="后进入"></a>后进入</h3><p>/usr/DPO_MT7601U_LinuxSTA_3.0.0.4_20130913/common目录，执行</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">gedit rtusb_dev_id.c”命令</span><br></pre></td></tr></table></figure>

<p>修改该文件：<br>找到</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> MT7601U</span></span><br><span class="line">&#123;USB_DEVICE(<span class="number">0x148f</span>,<span class="number">0x6370</span>)&#125;, <span class="comment">/* Ralink 6370 */</span></span><br><span class="line">&#123;USB_DEVICE(<span class="number">0x148f</span>,<span class="number">0x7601</span>)&#125;, <span class="comment">/* MT 6370 */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">/* MT7601U */</span>”</span></span><br><span class="line"></span><br><span class="line">在其中添加上“&#123;USB_DEVICE(<span class="number">0x2717</span>,<span class="number">0x4106</span>)&#125;,<span class="comment">/* XiaoMi wifi */</span>”</span><br></pre></td></tr></table></figure>
<p>如图：<br><img src="https://img-blog.csdn.net/20150507134811131?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzI2NzY4Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="pic"></p>
<p>这里要注意的是，如果你是其他的随身wifi设备的话，可以根据以下提示内容进行添加：</p>
<p>{USB_DEVICE(0x148f,0x760b)},/* 360 Wifi 2 Gen */</p>
<p>{USB_DEVICE(0x2955,0x1001)},/* Xiao Du Wifi */</p>
<p>{USB_DEVICE(0x2a5f,0x1000)},/* Quan Min Wifi */</p>
<h3 id="随后转到驱动源码根目录下执行，make指令"><a href="#随后转到驱动源码根目录下执行，make指令" class="headerlink" title="随后转到驱动源码根目录下执行，make指令"></a>随后转到驱动源码根目录下执行，make指令</h3><p>随后linux就会根据你刚刚修改的配置进行相应的编译，生成.ko文件</p>
<p>路径在界面中可以找到，如图：<br><img src="https://img-blog.csdn.net/20150507135609229?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxMzI2NzY4Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="pic2"><br>随后我们到该目录下将“mt7601Usta.ko”文件拷贝到ARM板中</p>
<p>但是在这操作过程中有一个很重要的点别漏了，否则无线网卡一样无法驱动成功</p>
<p>需要做的是，将该驱动源码根目录下的“RT2870STA.dat”文件拷贝到板中的”/etc/Wireless/RT2870STA/“目录下。</p>
<p>随后在Arm板的linux系统中安装刚刚编译好的驱动“insmod mt7601Usta.ko”，安装是否成功除了可以看提示外，还可以使用命令“lsmod”查看是否有安装该设备</p>
<p>PS：这里安装失败的话，一般是内核版本的问题，请检查你的内核版本是否与你linux下的armlinux的内核版本是否一致，或者arm-linux-gcc的版本是否符合要求，该问题在这里不多做解决的讲解</p>
<h3 id="安装成功后-即可插上相应的设备（随身WIFI）"><a href="#安装成功后-即可插上相应的设备（随身WIFI）" class="headerlink" title="安装成功后,即可插上相应的设备（随身WIFI）"></a>安装成功后,即可插上相应的设备（随身WIFI）</h3><p>不久，就会提示识别成功，出现一大段码，我就不贴出了</p>
<p>做到这里，你已经成功的将随身wifi移植到你的ARM板上了，但是你会发现，重启之后，该设备驱动又不见了，这是由于arm板每次重启就会还原一次这些驱动设备，所以，你需要修改初始化文件：</p>
<p>可以修改/etc/init.d目录下的rcS文件，在其中加入安装.ko文件的指令（PS：注意你的.ko文件的路径）<br>至此，已经驱动算是相对完整的成功了，也不担心重启还原的问题了，接下来，就讲解一下如何使用它来连接热点，即WIFI</p>
<h3 id="以上内容完成后，可以使用"><a href="#以上内容完成后，可以使用" class="headerlink" title="以上内容完成后，可以使用"></a>以上内容完成后，可以使用</h3><figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ifconfig -a</span><br></pre></td></tr></table></figure>
<p>就可以查看到你的无线网卡设备，即你的随身wifi，一般默认的设备名为“ra0”，默认是没有配置其他信息的，所以我们需要给它简单的配置一下，方便后期开发</p>
<p>但是在使用之前需要将arm板上的集成网卡先关闭掉，一般默认的名字为“eth0”，但是在关闭之前，我们得先执行以下操作</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 192.168.1.xxx</span><br></pre></td></tr></table></figure>
<p>xxx的取值为2-255，不要取230，或者身边已有的ip，因为，在同一网段上，不允许有两个相同的ip出现，而一般板上的初始ip为230， 所以要避开这些点，方便后期开发（PS：此处为建议）</p>
<p>之后关闭该网卡</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 down”</span><br></pre></td></tr></table></figure>
<p>后打开你的无线网卡</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">ifconfig ra0 192.168.1.xxx up</span><br></pre></td></tr></table></figure>
<p>解释同上</p>
<h3 id="此时网卡已经启动"><a href="#此时网卡已经启动" class="headerlink" title="此时网卡已经启动"></a>此时网卡已经启动</h3><p>但是你会发现用普通的wifi指令会提示找不到设备，如“scan-wifi”，因为随身wifi属于用户装置的设备，无法使用这些指令进行操控</p>
<p>所以在这里，我们得使用“iwlist”</p>
<p>输入iwlist的时候，你可以看到iwlist的各种功能，你可以根据功能提示进行相应的操作</p>
<p>比如，我们需要查看周围的热点信息，我们可以使用指令</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iwlist ra0 scan | less</span><br></pre></td></tr></table></figure>
<p>后界面中即会显示附近的热点信息</p>
<p>但是连接WIFI需要热点需要使用“iwconfig”这个操作指令</p>
<p>现在以连接假设附近有一个essid为“Test”的开放网络为例：</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line">iwconfig ra0 essid “Test”</span><br></pre></td></tr></table></figure>
<p>该指令结束后，即可在界面中查看到连接是否成功的信息</p>
<p>ps：其他更多热点加密方式的连接，请大家另外查询更多的指令信息，这里不多做讲解</p>
<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>完成以上部分，你的随身wifi就移植成功，并且能正常使用，接下的怎么应用怎么开发，就看你了~</p>
]]></content>
      <tags>
        <tag>Arm-Linux</tag>
      </tags>
  </entry>
</search>
