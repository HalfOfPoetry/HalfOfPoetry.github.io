<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【AI记录】机器学习与深度学习</title>
    <url>/2020/04/30/Deep-Learning/</url>
    <content><![CDATA[<h3 id="今天来讲讲机器学习-Machine-Learning，ML-与深度学习（Deep-Learning，DL）"><a href="#今天来讲讲机器学习-Machine-Learning，ML-与深度学习（Deep-Learning，DL）" class="headerlink" title="今天来讲讲机器学习(Machine Learning，ML)与深度学习（Deep Learning，DL）"></a>今天来讲讲机器学习(Machine Learning，ML)与深度学习（Deep Learning，DL）</h3><p>首先，要论这两个东西，得先了解人工智能（AI），AI与机器学习以及深度学习之间的关系，用集合关系来描述，就是：</p>
<p>深度学习包含于机器学习，机器学习包含于AI；</p>
<p>机器学习 作为AI的子领域，也是其核心，可以这么理解：</p>
<p>设计和分析一些算法，可以让计算机进行自动学习。</p>
<p>深度学习 设计灵感，是来源于人类大脑的工作方式，利用深度神经网络来解决特征表达的一种学习过程。为了提高深层神经网络的训练效果，人们对神经元的连接方法以及激活函数等方面做出了调整。其目的在于建立、模拟人脑进行分析学习的神经网络，模仿人脑的机制来解释数据，如文本、图像、声音。</p>
<h3 id="1-应用区别"><a href="#1-应用区别" class="headerlink" title="1.应用区别"></a>1.应用区别</h3><p>机器学习：指纹识别，特征物体检测等</p>
<p>深度学习：文字识别，人链技术，语义分析，智能监控，智能硬件，智能教育，智能医疗等</p>
<h3 id="2-需求的数据量"><a href="#2-需求的数据量" class="headerlink" title="2.需求的数据量"></a>2.需求的数据量</h3><p>机器学习：数据量较小</p>
<p>深度学习：在机器学习的基础上，若有比较庞大的数据量，深度学习的效果更加显著</p>
<h3 id="3-执行时间"><a href="#3-执行时间" class="headerlink" title="3.执行时间"></a>3.执行时间</h3><p>机器学习：相对较少</p>
<p>深度学习：由于训练受到数据量的影响，需要大量的时间进行</p>
<h3 id="4-问题解决方式"><a href="#4-问题解决方式" class="headerlink" title="4.问题解决方式"></a>4.问题解决方式</h3><p>机器学习：遵循标准化程序，将问题拆分，分别解决，之后整合得出答案</p>
<p>深度学习：不拆分，集中解决</p>
<h3 id="选择推荐："><a href="#选择推荐：" class="headerlink" title="选择推荐："></a>选择推荐：</h3><p>传统的机器学习算法比较复杂，不太容易理解，深度学习引入了人工神经网络，比机器学习的表现要好得多，在数据量足够庞大的情况下，个人建议使用选择深度学习。</p>
]]></content>
      <tags>
        <tag>Deep-Learing</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux下send错误代码32</title>
    <url>/2020/04/30/Linux%E4%B8%8Bsend%E9%94%99%E8%AF%AF%E4%BB%A3%E7%A0%8132/</url>
    <content><![CDATA[<h3 id="问题描述：今天写程序，socket后send出现这个问题，send的返回值为-1，而errno为32，这个错误代码为broken-pipe，即管道破裂。"><a href="#问题描述：今天写程序，socket后send出现这个问题，send的返回值为-1，而errno为32，这个错误代码为broken-pipe，即管道破裂。" class="headerlink" title="问题描述：今天写程序，socket后send出现这个问题，send的返回值为-1，而errno为32，这个错误代码为broken pipe，即管道破裂。"></a>问题描述：今天写程序，socket后send出现这个问题，send的返回值为-1，而errno为32，这个错误代码为broken pipe，即管道破裂。</h3><p>问题形成原因：后来通过排查研究，发现出现该种问题出现的可能性为以下两种：</p>
<p>1.socket失败，与服务器端的链接没有成功，从而管道破裂。</p>
<p>2.服务端将客户端的socket断开，一样造成这样的问题。</p>
<h3 id="此时这样的程序收到broken-pipe的信号，会自动退出我们可以在产生信号前利用方法-signal-int-signum-sighandler-t-handler-设置信号的处理。如果没有调用此方法，系统就会调用默认处理方法：中止程序，显示提示信息-就是我们经常遇到的问题-。我们可以调用系统的处理方法，也可以自定义处理方法。"><a href="#此时这样的程序收到broken-pipe的信号，会自动退出我们可以在产生信号前利用方法-signal-int-signum-sighandler-t-handler-设置信号的处理。如果没有调用此方法，系统就会调用默认处理方法：中止程序，显示提示信息-就是我们经常遇到的问题-。我们可以调用系统的处理方法，也可以自定义处理方法。" class="headerlink" title="此时这样的程序收到broken pipe的信号，会自动退出我们可以在产生信号前利用方法 signal(int signum, sighandler_t handler) 设置信号的处理。如果没有调用此方法，系统就会调用默认处理方法：中止程序，显示提示信息(就是我们经常遇到的问题)。我们可以调用系统的处理方法，也可以自定义处理方法。"></a>此时这样的程序收到broken pipe的信号，会自动退出我们可以在产生信号前利用方法 signal(int signum, sighandler_t handler) 设置信号的处理。如果没有调用此方法，系统就会调用默认处理方法：中止程序，显示提示信息(就是我们经常遇到的问题)。我们可以调用系统的处理方法，也可以自定义处理方法。</h3><p>对一个已经收到FIN包的socket调用read方法, 如果接收缓冲已空, 则返回0,<br>这就是常说的表示连接关闭. 但第一次对其调用write方法时, 如果发送缓冲没问题,<br>会返回正确写入(发送). 但发送的报文会导致对端发送RST报文,<br>因为对端的socket已经调用了close, 完全关闭, 既不发送, 也不接收数据. 所以,<br>第二次调用write方法(假设在收到RST之后), 会生成SIGPIPE信号, 导致进程退出.</p>
<h3 id="为了避免进程退出-可以捕获SIGPIPE信号-或者忽略它"><a href="#为了避免进程退出-可以捕获SIGPIPE信号-或者忽略它" class="headerlink" title="为了避免进程退出, 可以捕获SIGPIPE信号, 或者忽略它,"></a>为了避免进程退出, 可以捕获SIGPIPE信号, 或者忽略它,</h3><p>给它设置SIG_IGN信号处理函数:</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">signal(SIGPIPE, SIG_IGN);</span><br></pre></td></tr></table></figure>
<p>这样, 第二次调用write方法时, 会返回-1, 同时errno置为SIGPIPE.<br>程序便能知道对端已经关闭.</p>
]]></content>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>DLL注入之注册表注入</title>
    <url>/2020/05/07/DLL%E6%B3%A8%E5%85%A5%E4%B9%8B%E6%B3%A8%E5%86%8C%E8%A1%A8%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h3 id="注册表注入DLL"><a href="#注册表注入DLL" class="headerlink" title="注册表注入DLL"></a>注册表注入DLL</h3><p>顾名思义，就是通过注册表的方式，把需要的执行的代码片段，注入到目标程序中，使目标程序执行指定的代码片段，从而达到预期效果。<br>该方式依赖user32.dll，也就是说，需要可执行程序调用到这个系统动态库，我们注入的dll才会被执行到。<br>你应该也发现了，这个意思就是这是一种全局的注入，也就是说，所有调用到user32.dll的程序，都会调用到我们注入成功的dll，所以用这种方式还是要精心设计一下程序思路和限制条件。</p>
<h3 id="注册表位置："><a href="#注册表位置：" class="headerlink" title="注册表位置："></a>注册表位置：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; AppInit_Dlls(64位程序读取)</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows [AppInit_DLLs]</span><br><span class="line"></span><br><span class="line">AppInit_Dlls(32位程序读取)</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows [AppInit_DLLs]</span><br><span class="line"></span><br><span class="line">32位系统：</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows [AppInit_DLLs]</span><br></pre></td></tr></table></figure>
<h3 id="注册表的认识："><a href="#注册表的认识：" class="headerlink" title="注册表的认识："></a>注册表的认识：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 注册表根：</span><br><span class="line">&#x2F;&#x2F; HKEY_CLASSES_ROOT</span><br><span class="line">&#x2F;&#x2F; HKEY_LOCAL_MACHINE</span><br><span class="line">&#x2F;&#x2F; HKEY_CURRENT_USER</span><br><span class="line">&#x2F;&#x2F; HKEY_USERS</span><br><span class="line">&#x2F;&#x2F; HKEY_CURRENT_CONFIG</span><br></pre></td></tr></table></figure>
<p>这几个的意义不多做阐述，需要自行了解每个节点的意义，但是其实从命名上也能猜出一二<br>需要了解的是这几个玩意儿：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; AppInit_DLLs  LoadAppInit_DLLs RequireSignedAppInit_DLLs</span><br></pre></td></tr></table></figure>
<p>AppInit_DLLs:是注册表在中的一个系统设置项，它的值可以为一个dll路径列表,其实这里就是我们要注入的dll（注意：这里是全局注入）<br>LoadAppInit_DLLs：真正做过该内容开发的人，就会发现，xp下是没有这个项的，而大于win7的系统版本下才有这个项，LoadAppInit_DLLs 为1开启，为0关闭，（Win7默认为0）<br>RequireSignedAppInit_DLLs：这个的xp下也是没有的，值为1表明模块需要签名才能加载，反之则不行</p>
<p>AppInit_DLLs详细的键值介绍，可以查看官方文档（Win7）：<br><a href="https://docs.microsoft.com/zh-cn/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2?redirectedfrom=MSDN" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/windows/win32/win7appqual/appinit-dlls-in-windows-7-and-windows-server-2008-r2?redirectedfrom=MSDN</a></p>
<h3 id="需要认识的API"><a href="#需要认识的API" class="headerlink" title="需要认识的API"></a>需要认识的API</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; API: RegOpenKeyEx RegSetValueEx RegQueryValueEx RegCloseKey</span><br><span class="line">&#x2F;&#x2F; 权限：KEY_READ KEY_WRITE KEY_EXECUTE KEY_ALL_ACCESS</span><br><span class="line">&#x2F;&#x2F; 涉及的数据类型：REG_SZ REG_DWORD</span><br></pre></td></tr></table></figure>
<p>RegOpenKeyEx：打开注册表路径，调用时候，只需要打开到所需要修改设置项的路径，例如：HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows （真正调用的时候注意转义）<br>再打开注册表的时候，可以通过设置：KEY_READ KEY_WRITE KEY_EXECUTE KEY_ALL_ACCESS来获取读写权限，当然也有可能获取失败的时候，所以要关注返回值</p>
<p>RegQueryValueEx：查询对应的键值<br>RegSetValueEx：设置键值<br>RegCloseKey：关闭当前打开的注册表<br>在调用过程中注意返回值类型，可以用ERROR_SUCCESS去判断是否调用成功，其他类型可以查看相关文档。<br>其他不做赘述了</p>
<h3 id="写一个简单demo："><a href="#写一个简单demo：" class="headerlink" title="写一个简单demo："></a>写一个简单demo：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	HKEY hKey;</span><br><span class="line">	<span class="keyword">char</span> *csAppInitValue = <span class="string">"C:\\test.dll"</span>;</span><br><span class="line">	DWORD dwLoadAppInitValue = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> csSubKey[] = <span class="string">"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows\\"</span>;</span><br><span class="line">    LSTATUS lsRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,csSubKey,<span class="number">0</span>,KEY_ALL_ACCESS,&amp;hKey);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lsRet != ERROR_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Open Key Failed....\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">char</span> csBuf[<span class="number">100</span>] = <span class="string">""</span>;</span><br><span class="line">	DWORD dwSize = <span class="number">100</span>;</span><br><span class="line">	DWORD dwType = <span class="number">0</span>;</span><br><span class="line">	RegQueryValueEx(hKey,<span class="string">"AppInit_DLLs"</span>,<span class="number">0</span>,&amp;dwType,(LPBYTE)csBuf,&amp;dwSize);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> nSize = <span class="built_in">strlen</span>(csAppInitValue);</span><br><span class="line">	lsRet = RegSetValueEx(hKey,<span class="string">"AppInit_DLLs"</span>,<span class="number">0</span>,REG_SZ,(<span class="keyword">const</span> BYTE *)csAppInitValue,nSize+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lsRet != ERROR_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Set Key Failed....\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	</span><br><span class="line"></span><br><span class="line">	lsRet = RegSetValueEx(hKey,<span class="string">"LoadAppInit_DLLs"</span>,<span class="number">0</span>,REG_DWORD,(<span class="keyword">const</span> BYTE *)&amp;dwLoadAppInitValue,<span class="keyword">sizeof</span>(DWORD));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (lsRet != ERROR_SUCCESS)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Set Key Failed....\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	RegCloseKey(hKey);</span><br><span class="line"></span><br><span class="line">    getchar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>对了，如何查看程序调用了哪些dll，这是一个新手问题，在这里我推荐一个很好用的工具：Process Explorer<br>这个工具，可以定位程序包括pid与调用的动态库等几乎所有的程序相关信息，具体怎么用，可以自行网络搜索，或者后续等我出一篇使用经验，哈哈哈，这个可能要等很久。<br>有兴趣可以联系我，一起分享学习经验，哈哈哈~</p>
]]></content>
      <tags>
        <tag>Dll_Inject</tag>
      </tags>
  </entry>
  <entry>
    <title>Welcome</title>
    <url>/2020/04/30/Welcome/</url>
    <content><![CDATA[<h2 id="这是开始"><a href="#这是开始" class="headerlink" title="这是开始"></a>这是开始</h2><p>欢迎来到这里<br>我会在这里<br>分享日常<br>分享代码<br>分享生活  </p>
<p>ありがとうございます</p>
]]></content>
      <tags>
        <tag>welcome</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows编程之DLL注入</title>
    <url>/2020/05/07/Windows%E7%BC%96%E7%A8%8B%E4%B9%8BDLL%E6%B3%A8%E5%85%A5/</url>
    <content><![CDATA[<h3 id="Windows编程中不得不懂的一项实用技巧"><a href="#Windows编程中不得不懂的一项实用技巧" class="headerlink" title="Windows编程中不得不懂的一项实用技巧"></a>Windows编程中不得不懂的一项实用技巧</h3><p>就是DLL动态库注入技术</p>
<p>关于这一系列的注入知识，后续会针对每一项技巧进行专门的博文编写<br>这篇博文，简单讲述现在常用的四种技巧</p>
<h3 id="一、注册表注入"><a href="#一、注册表注入" class="headerlink" title="一、注册表注入"></a>一、注册表注入</h3><p>顾名思义，就是通过注册表的方式，把需要的执行的代码片段，注入到目标程序中，使目标程序执行指定的代码片段，从而达到预期效果。</p>
<h3 id="二、函数转发注入"><a href="#二、函数转发注入" class="headerlink" title="二、函数转发注入"></a>二、函数转发注入</h3><p>这个方式，是通过替换目标程序的动态库，可以定义dll入口等函数，而后转发原函数调用内容至原动态库函数接口，这样的动作之后，就可以调用注入的代码片段，从而达到预期效果。</p>
<h3 id="三、挂钩注入"><a href="#三、挂钩注入" class="headerlink" title="三、挂钩注入"></a>三、挂钩注入</h3><p>这项技术，要是有了解过钩子技术的人就会比较容易懂，主要通过挂钩相关程序下，或者全局下的相关消息，或者理解成捕获目标消息后，执行指定代码片段，从而达到预期效果。</p>
<h3 id="四、远程注入"><a href="#四、远程注入" class="headerlink" title="四、远程注入"></a>四、远程注入</h3><p>这里的远程，不要想得太复杂，不是我们平时所谓的网络中的远程，这里的意思是，通过控制内存，在内存段上为目标程序开辟一条线程，之后控制该线程执行相关的DLL。</p>
<h3 id="以上四种方式就是常用的几种DLL注入技巧"><a href="#以上四种方式就是常用的几种DLL注入技巧" class="headerlink" title="以上四种方式就是常用的几种DLL注入技巧"></a>以上四种方式就是常用的几种DLL注入技巧</h3><p>都各自有利有弊<br>注册表注入的方式，最简单，但是这种方式依赖于user32.dll这个系统自带dll，当可执行程序需要调用到这个动态库，才可形成注入，而且我试过win8，win10下好像支持效果不是太好；<br>函数转发的方式，最直观，但是现在大多数企业级的目标程序，是对DLL进行注册校验的，一旦出现非法dll则无法实现效果，所以需要采取该方式的dll开发商，需要经过认证；<br>挂钩的方式，弊端就在于依赖于windows的消息，无消息则无法注入；<br>远程注入的方式是个人相对推荐的，其实认真想想某些病毒就是通过这样的手段，使病毒程序执行于无形之中。</p>
<p>后续有空的话，我会详细编写各个方式的实现博文，写在这里，激励自己写下去的动力。</p>
]]></content>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>python猜数字小游戏</title>
    <url>/2020/04/30/python%E7%8C%9C%E6%95%B0%E5%AD%97/</url>
    <content><![CDATA[<h3 id="这是一个学习项目"><a href="#这是一个学习项目" class="headerlink" title="这是一个学习项目"></a>这是一个学习项目</h3><p>游戏原理介绍：</p>
<p>这个猜数字的小游戏，相信很多人以前玩过，就是一个人从1-100中随机写一个数字，然后另外一群人去猜，猜一个数字的时候，就会告诉你所猜的数字大了还是小了，渐渐缩小范围，直到最后猜对的人，为最后的胜利者。</p>
<p>现在把生成数字和裁判的角色，交给代码，这样即使只有自己一个人的时候，也可以玩这样的游戏</p>
<p>经过上述游戏分析，我们就可以开始一套简单的思路</p>
<p>1.随机数的生成，我们就得需要用到random模块</p>
<p>2.猜数字的次数为多次，所以我们需要封装一个猜数字的函数</p>
<p>3.需要记录猜数字的区间范围</p>
<p>4.得防止用户使用不得当，输入字符不符导致程序异常</p>
<p>5.游戏过程中玩家终止游戏操作</p>
<h3 id="于是，我们可以根据思路简单编写一下代码："><a href="#于是，我们可以根据思路简单编写一下代码：" class="headerlink" title="于是，我们可以根据思路简单编写一下代码："></a>于是，我们可以根据思路简单编写一下代码：</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">n = random.randint(<span class="number">1</span>,<span class="number">100</span>) <span class="comment"># 生成1 - 100的随机整</span></span><br><span class="line"></span><br><span class="line">step = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">low = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">high = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_number</span><span class="params">(low = <span class="number">1</span>,high = <span class="number">100</span>)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"Please enter an integer"</span>,low,<span class="string">"to"</span>,high,<span class="string">":"</span>)</span><br><span class="line"></span><br><span class="line">        guess = input()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> guess.isdigit():<span class="comment"># 字符串是否为数字，是True，否False</span></span><br><span class="line"></span><br><span class="line">            guess = int(guess)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> guess</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(<span class="string">"Game Init"</span>)</span><br><span class="line"></span><br><span class="line">guess = get_number()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"></span><br><span class="line">    step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"step :"</span>,step)</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> guess == <span class="number">0</span>:</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"quit"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> guess &lt; n:</span><br><span class="line"></span><br><span class="line">        print(guess,<span class="string">"is low"</span>)</span><br><span class="line"></span><br><span class="line">        low = guess + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">elif</span> guess &gt; n:</span><br><span class="line"></span><br><span class="line">        print(guess,<span class="string">"is high"</span>)</span><br><span class="line"></span><br><span class="line">        high = guess - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"you win!"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    guess = get_number(low,high) <span class="comment"># 继续猜</span></span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">print(<span class="string">"Game Over"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="执行结果如下："><a href="#执行结果如下：" class="headerlink" title="执行结果如下："></a>执行结果如下：</h3><p><img src="https://img-blog.csdnimg.cn/20200323150728216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNjc2ODc=,size_16,color_FFFFFF,t_70" alt="图片"></p>
<p>简单易学，轻松上手</p>
<p>可以根据自己对游戏的理解和需求，封装更多有趣的玩法</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>利用python3写一个简单的百度翻译小字典</title>
    <url>/2020/04/30/python%E7%99%BE%E5%BA%A6%E5%AD%97%E5%85%B8/</url>
    <content><![CDATA[<h3 id="利用python3写一个简单的百度翻译小字典"><a href="#利用python3写一个简单的百度翻译小字典" class="headerlink" title="利用python3写一个简单的百度翻译小字典"></a>利用python3写一个简单的百度翻译小字典</h3><p>声明：此例子为学习例子，通过百度翻译的XHR来实现的</p>
<p>最近在重新学习python3，尝试着利用它来抓取网页上的数据。</p>
<p>在用百度翻译的时候，看到<br><img src="https://img-blog.csdnimg.cn/20200306170733883.png" alt="pic"><br>突发奇想想做一个百度小字典的玩意儿</p>
<p>于是开始了学习之路</p>
<h3 id="首先利用浏览器的网页工具查看其工作原理是利用xhr请求来获取数据"><a href="#首先利用浏览器的网页工具查看其工作原理是利用xhr请求来获取数据" class="headerlink" title="首先利用浏览器的网页工具查看其工作原理是利用xhr请求来获取数据"></a>首先利用浏览器的网页工具查看其工作原理是利用xhr请求来获取数据</h3><p>于是我们可以<br><img src="https://img-blog.csdnimg.cn/20200306171320636.png" alt="pic2"><br>在network工具下选择xhr协议</p>
<p>在preview模式中找到具体的流数据（json）<br><img src="https://img-blog.csdnimg.cn/20200306171540999.png" alt="pic3"><br>在headres中我们最先注意的只有两个<br><img src="https://img-blog.csdnimg.cn/20200306171916906.png" alt="pic4"><br>就是找到Request Url和Method，很明显是<a href="https://fanyi.baidu.com/sug和post" target="_blank" rel="noopener">https://fanyi.baidu.com/sug和post</a></p>
<p>所以我们确定了用到的东西有</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests        <span class="comment">#导入requests包</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> json</span><br></pre></td></tr></table></figure>
<p>既然是post，我们就得去寻找post的数据是什么<br><img src="https://img-blog.csdnimg.cn/2020030617224252.png" alt="pic5"><br>可以发现，这是一个很简单的数据模式</p>
<h3 id="我们就可以先定义"><a href="#我们就可以先定义" class="headerlink" title="我们就可以先定义"></a>我们就可以先定义</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">From_data = &#123;<span class="string">'kw'</span>,<span class="string">'hello'</span>&#125;</span><br><span class="line"></span><br><span class="line">url = <span class="string">'https://fanyi.baidu.com/sug'</span></span><br></pre></td></tr></table></figure>
<p>请求方式：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">response = requests.post(url,data=From_data)</span><br></pre></td></tr></table></figure>

<p>获取表单方式后进行json转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">content = json.loads(response.text)</span><br></pre></td></tr></table></figure>
<p>content中有即是我们要的查询结果。</p>
<h3 id="截图运行效果如下（截图附代码）："><a href="#截图运行效果如下（截图附代码）：" class="headerlink" title="截图运行效果如下（截图附代码）："></a>截图运行效果如下（截图附代码）：</h3><p><img src="https://img-blog.csdnimg.cn/202003061727026.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTMyNjc2ODc=,size_16,color_FFFFFF,t_70" alt="pic6"><br>后面的格式如何转换，就是进一步的事了，这简单的百度小词典就完成啦~</p>
<p>PS：利用这种方式，可以实现很多借用第三方的功能。</p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
